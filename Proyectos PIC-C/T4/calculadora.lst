CCS PCM C Compiler, Version 4.049, 34317               13-ago-13 11:35

               Filename: C:\Users\Administrador\Desktop\Proyectos PIC-C\T4\calculadora.lst

               ROM used: 1115 words (14%)
                         Largest free fragment is 2048
               RAM used: 37 (10%) at main() level
                         49 (13%) worst case
               Stack:    2 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   35E
0003:  NOP
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float32 strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
036D:  BCF    03.5
036E:  CLRF   20
036F:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0196:  CLRF   44
....................    sign = 0; 
0197:  CLRF   42
....................    base = 10; 
0198:  MOVLW  0A
0199:  MOVWF  43
....................    result = 0; 
019A:  CLRF   41
019B:  CLRF   40
....................  
....................    if (!s) 
019C:  MOVF   3E,W
019D:  IORWF  3F,W
019E:  BTFSS  03.2
019F:  GOTO   1A4
....................       return 0; 
01A0:  MOVLW  00
01A1:  MOVWF  78
01A2:  MOVWF  79
01A3:  GOTO   29D
....................    c = s[index++]; 
01A4:  MOVF   44,W
01A5:  INCF   44,F
01A6:  ADDWF  3E,W
01A7:  MOVWF  04
01A8:  BCF    03.7
01A9:  BTFSC  3F.0
01AA:  BSF    03.7
01AB:  MOVF   00,W
01AC:  MOVWF  45
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
01AD:  MOVF   45,W
01AE:  SUBLW  2D
01AF:  BTFSS  03.2
01B0:  GOTO   1BD
....................    { 
....................       sign = 1;         // Set the sign to negative 
01B1:  MOVLW  01
01B2:  MOVWF  42
....................       c = s[index++]; 
01B3:  MOVF   44,W
01B4:  INCF   44,F
01B5:  ADDWF  3E,W
01B6:  MOVWF  04
01B7:  BCF    03.7
01B8:  BTFSC  3F.0
01B9:  BSF    03.7
01BA:  MOVF   00,W
01BB:  MOVWF  45
....................    } 
....................    else if (c == '+') 
01BC:  GOTO   1CA
01BD:  MOVF   45,W
01BE:  SUBLW  2B
01BF:  BTFSS  03.2
01C0:  GOTO   1CA
....................    { 
....................       c = s[index++]; 
01C1:  MOVF   44,W
01C2:  INCF   44,F
01C3:  ADDWF  3E,W
01C4:  MOVWF  04
01C5:  BCF    03.7
01C6:  BTFSC  3F.0
01C7:  BSF    03.7
01C8:  MOVF   00,W
01C9:  MOVWF  45
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
01CA:  MOVF   45,W
01CB:  SUBLW  2F
01CC:  BTFSC  03.0
01CD:  GOTO   28E
01CE:  MOVF   45,W
01CF:  SUBLW  39
01D0:  BTFSS  03.0
01D1:  GOTO   28E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
01D2:  MOVF   45,W
01D3:  SUBLW  30
01D4:  BTFSS  03.2
01D5:  GOTO   1F6
01D6:  MOVF   44,W
01D7:  ADDWF  3E,W
01D8:  MOVWF  04
01D9:  BCF    03.7
01DA:  BTFSC  3F.0
01DB:  BSF    03.7
01DC:  MOVF   00,W
01DD:  SUBLW  78
01DE:  BTFSC  03.2
01DF:  GOTO   1EA
01E0:  MOVF   44,W
01E1:  ADDWF  3E,W
01E2:  MOVWF  04
01E3:  BCF    03.7
01E4:  BTFSC  3F.0
01E5:  BSF    03.7
01E6:  MOVF   00,W
01E7:  SUBLW  58
01E8:  BTFSS  03.2
01E9:  GOTO   1F6
....................       { 
....................          base = 16; 
01EA:  MOVLW  10
01EB:  MOVWF  43
....................          index++; 
01EC:  INCF   44,F
....................          c = s[index++]; 
01ED:  MOVF   44,W
01EE:  INCF   44,F
01EF:  ADDWF  3E,W
01F0:  MOVWF  04
01F1:  BCF    03.7
01F2:  BTFSC  3F.0
01F3:  BSF    03.7
01F4:  MOVF   00,W
01F5:  MOVWF  45
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
01F6:  MOVF   43,W
01F7:  SUBLW  0A
01F8:  BTFSS  03.2
01F9:  GOTO   21D
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
01FA:  MOVF   45,W
01FB:  SUBLW  2F
01FC:  BTFSC  03.0
01FD:  GOTO   21C
01FE:  MOVF   45,W
01FF:  SUBLW  39
0200:  BTFSS  03.0
0201:  GOTO   21C
....................             result = 10*result + (c - '0'); 
0202:  CLRF   47
0203:  MOVLW  0A
0204:  MOVWF  46
0205:  MOVF   41,W
0206:  MOVWF  49
0207:  MOVF   40,W
0208:  MOVWF  48
0209:  CALL   181
020A:  MOVLW  30
020B:  SUBWF  45,W
020C:  ADDWF  78,W
020D:  MOVWF  40
020E:  MOVF   79,W
020F:  MOVWF  41
0210:  BTFSC  03.0
0211:  INCF   41,F
....................             c = s[index++]; 
0212:  MOVF   44,W
0213:  INCF   44,F
0214:  ADDWF  3E,W
0215:  MOVWF  04
0216:  BCF    03.7
0217:  BTFSC  3F.0
0218:  BSF    03.7
0219:  MOVF   00,W
021A:  MOVWF  45
....................          } 
021B:  GOTO   1FA
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
021C:  GOTO   28E
021D:  MOVF   43,W
021E:  SUBLW  10
021F:  BTFSS  03.2
0220:  GOTO   28E
....................       { 
....................          c = toupper(c); 
0221:  MOVF   45,W
0222:  SUBLW  60
0223:  BTFSC  03.0
0224:  GOTO   22C
0225:  MOVF   45,W
0226:  SUBLW  7A
0227:  BTFSS  03.0
0228:  GOTO   22C
0229:  MOVF   45,W
022A:  ANDLW  DF
022B:  GOTO   22D
022C:  MOVF   45,W
022D:  MOVWF  45
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
022E:  MOVF   45,W
022F:  SUBLW  2F
0230:  BTFSC  03.0
0231:  GOTO   236
0232:  MOVF   45,W
0233:  SUBLW  39
0234:  BTFSC  03.0
0235:  GOTO   23E
0236:  MOVF   45,W
0237:  SUBLW  40
0238:  BTFSC  03.0
0239:  GOTO   28E
023A:  MOVF   45,W
023B:  SUBLW  46
023C:  BTFSS  03.0
023D:  GOTO   28E
....................             if (c >= '0' && c <= '9') 
023E:  MOVF   45,W
023F:  SUBLW  2F
0240:  BTFSC  03.0
0241:  GOTO   25F
0242:  MOVF   45,W
0243:  SUBLW  39
0244:  BTFSS  03.0
0245:  GOTO   25F
....................                result = (result << 4) + (c - '0'); 
0246:  RLF    40,W
0247:  MOVWF  46
0248:  RLF    41,W
0249:  MOVWF  47
024A:  RLF    46,F
024B:  RLF    47,F
024C:  RLF    46,F
024D:  RLF    47,F
024E:  RLF    46,F
024F:  RLF    47,F
0250:  MOVLW  F0
0251:  ANDWF  46,F
0252:  MOVLW  30
0253:  SUBWF  45,W
0254:  ADDWF  46,W
0255:  MOVWF  78
0256:  MOVF   47,W
0257:  MOVWF  7A
0258:  BTFSC  03.0
0259:  INCF   7A,F
025A:  MOVF   78,W
025B:  MOVWF  40
025C:  MOVF   7A,W
025D:  MOVWF  41
....................             else 
025E:  GOTO   278
....................                result = (result << 4) + (c - 'A' + 10); 
025F:  RLF    40,W
0260:  MOVWF  46
0261:  RLF    41,W
0262:  MOVWF  47
0263:  RLF    46,F
0264:  RLF    47,F
0265:  RLF    46,F
0266:  RLF    47,F
0267:  RLF    46,F
0268:  RLF    47,F
0269:  MOVLW  F0
026A:  ANDWF  46,F
026B:  MOVLW  41
026C:  SUBWF  45,W
026D:  ADDLW  0A
026E:  ADDWF  46,W
026F:  MOVWF  78
0270:  MOVF   47,W
0271:  MOVWF  7A
0272:  BTFSC  03.0
0273:  INCF   7A,F
0274:  MOVF   78,W
0275:  MOVWF  40
0276:  MOVF   7A,W
0277:  MOVWF  41
....................  
....................             c = s[index++];c = toupper(c); 
0278:  MOVF   44,W
0279:  INCF   44,F
027A:  ADDWF  3E,W
027B:  MOVWF  04
027C:  BCF    03.7
027D:  BTFSC  3F.0
027E:  BSF    03.7
027F:  MOVF   00,W
0280:  MOVWF  45
0281:  SUBLW  60
0282:  BTFSC  03.0
0283:  GOTO   28B
0284:  MOVF   45,W
0285:  SUBLW  7A
0286:  BTFSS  03.0
0287:  GOTO   28B
0288:  MOVF   45,W
0289:  ANDLW  DF
028A:  GOTO   28C
028B:  MOVF   45,W
028C:  MOVWF  45
....................          } 
028D:  GOTO   22E
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
028E:  MOVF   43,W
028F:  SUBLW  0A
0290:  BTFSS  03.2
0291:  GOTO   299
0292:  DECFSZ 42,W
0293:  GOTO   299
....................       result = -result; 
0294:  COMF   40,F
0295:  COMF   41,F
0296:  INCF   40,F
0297:  BTFSC  03.2
0298:  INCF   41,F
....................  
....................    return(result); 
0299:  MOVF   40,W
029A:  MOVWF  78
029B:  MOVF   41,W
029C:  MOVWF  79
.................... } 
029D:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock = 4M) 
.................... #use RS232 (baud = 9600, bits = 8, parity = N, xmit = pin_b0, rcv = pin_b2) 
*
013A:  BSF    03.5
013B:  BCF    06.0
013C:  BCF    03.5
013D:  BCF    06.0
013E:  MOVLW  08
013F:  MOVWF  78
0140:  GOTO   141
0141:  NOP
0142:  BSF    78.7
0143:  GOTO   152
0144:  BCF    78.7
0145:  RRF    48,F
0146:  BTFSC  03.0
0147:  BSF    06.0
0148:  BTFSS  03.0
0149:  BCF    06.0
014A:  BSF    78.6
014B:  GOTO   152
014C:  BCF    78.6
014D:  DECFSZ 78,F
014E:  GOTO   145
014F:  GOTO   150
0150:  NOP
0151:  BSF    06.0
0152:  MOVLW  1C
0153:  MOVWF  04
0154:  DECFSZ 04,F
0155:  GOTO   154
0156:  GOTO   157
0157:  BTFSC  78.7
0158:  GOTO   144
0159:  BTFSC  78.6
015A:  GOTO   14C
015B:  RETLW  00
015C:  BSF    03.5
015D:  BSF    06.2
015E:  BCF    03.5
015F:  BTFSC  06.2
0160:  GOTO   15F
0161:  MOVLW  08
0162:  MOVWF  77
0163:  CLRF   3E
0164:  BSF    77.7
0165:  GOTO   174
0166:  BCF    77.7
0167:  GOTO   174
0168:  BCF    03.0
0169:  BTFSC  06.2
016A:  BSF    03.0
016B:  RRF    3E,F
016C:  BSF    77.6
016D:  GOTO   174
016E:  BCF    77.6
016F:  DECFSZ 77,F
0170:  GOTO   168
0171:  MOVF   3E,W
0172:  MOVWF  78
0173:  GOTO   180
0174:  MOVLW  1C
0175:  BTFSC  77.7
0176:  MOVLW  07
0177:  MOVWF  78
0178:  DECFSZ 78,F
0179:  GOTO   178
017A:  NOP
017B:  BTFSC  77.7
017C:  GOTO   166
017D:  BTFSC  77.6
017E:  GOTO   16E
017F:  GOTO   168
0180:  RETLW  00
....................  
....................  
.................... void main () { 
*
035E:  CLRF   04
035F:  BCF    03.7
0360:  MOVLW  1F
0361:  ANDWF  03,F
0362:  BSF    03.5
0363:  BCF    06.0
0364:  BCF    03.5
0365:  BSF    06.0
0366:  BSF    03.5
0367:  BSF    1F.0
0368:  BSF    1F.1
0369:  BSF    1F.2
036A:  BCF    1F.3
036B:  MOVLW  07
036C:  MOVWF  1C
....................  
....................    char caracter1 [6]; 
....................    char caracter2 [6]; 
....................     
....................    signed long X; 
....................    signed long Y; 
....................     
....................    signed long suma; 
....................    signed long resta; 
....................    signed long multiplicacion; 
....................    signed long division; 
....................     
....................    printf ("Seor usuario digite su primer Numero\r"); 
*
0370:  CLRF   3E
0371:  MOVF   3E,W
0372:  CALL   004
0373:  INCF   3E,F
0374:  MOVWF  77
0375:  MOVWF  48
0376:  CALL   13A
0377:  MOVLW  26
0378:  SUBWF  3E,W
0379:  BTFSS  03.2
037A:  GOTO   371
....................    gets (caracter1); 
037B:  MOVLW  26
037C:  MOVWF  04
037D:  BCF    03.7
037E:  DECF   04,F
037F:  INCF   04,F
0380:  CALL   15C
0381:  MOVF   78,W
0382:  MOVWF  00
0383:  MOVLW  0D
0384:  SUBWF  00,W
0385:  BTFSS  03.2
0386:  GOTO   37F
0387:  CLRF   00
....................    X = atol (caracter1); 
0388:  CLRF   3F
0389:  MOVLW  26
038A:  MOVWF  3E
038B:  CALL   196
038C:  MOVF   79,W
038D:  MOVWF  33
038E:  MOVF   78,W
038F:  MOVWF  32
....................    printf ("El primer numero es: %Ld\r", X); 
0390:  CLRF   3E
0391:  MOVF   3E,W
0392:  CALL   02F
0393:  INCF   3E,F
0394:  MOVWF  77
0395:  MOVWF  48
0396:  CALL   13A
0397:  MOVLW  15
0398:  SUBWF  3E,W
0399:  BTFSS  03.2
039A:  GOTO   391
039B:  MOVLW  10
039C:  MOVWF  04
039D:  MOVF   33,W
039E:  MOVWF  40
039F:  MOVF   32,W
03A0:  MOVWF  3F
03A1:  CALL   29E
03A2:  MOVLW  0D
03A3:  MOVWF  48
03A4:  CALL   13A
....................        
....................    printf ("Seor usuario digite su segundo Numero\r"); 
03A5:  CLRF   3E
03A6:  MOVF   3E,W
03A7:  CALL   04D
03A8:  INCF   3E,F
03A9:  MOVWF  77
03AA:  MOVWF  48
03AB:  CALL   13A
03AC:  MOVLW  27
03AD:  SUBWF  3E,W
03AE:  BTFSS  03.2
03AF:  GOTO   3A6
....................    gets (caracter2); 
03B0:  MOVLW  2C
03B1:  MOVWF  04
03B2:  BCF    03.7
03B3:  DECF   04,F
03B4:  INCF   04,F
03B5:  CALL   15C
03B6:  MOVF   78,W
03B7:  MOVWF  00
03B8:  MOVLW  0D
03B9:  SUBWF  00,W
03BA:  BTFSS  03.2
03BB:  GOTO   3B4
03BC:  CLRF   00
....................    Y = atol (caracter2); 
03BD:  CLRF   3F
03BE:  MOVLW  2C
03BF:  MOVWF  3E
03C0:  CALL   196
03C1:  MOVF   79,W
03C2:  MOVWF  35
03C3:  MOVF   78,W
03C4:  MOVWF  34
....................    printf ("El segundo numero es: %Ld\r", Y); 
03C5:  CLRF   3E
03C6:  MOVF   3E,W
03C7:  CALL   079
03C8:  INCF   3E,F
03C9:  MOVWF  77
03CA:  MOVWF  48
03CB:  CALL   13A
03CC:  MOVLW  16
03CD:  SUBWF  3E,W
03CE:  BTFSS  03.2
03CF:  GOTO   3C6
03D0:  MOVLW  10
03D1:  MOVWF  04
03D2:  MOVF   35,W
03D3:  MOVWF  40
03D4:  MOVF   34,W
03D5:  MOVWF  3F
03D6:  CALL   29E
03D7:  MOVLW  0D
03D8:  MOVWF  48
03D9:  CALL   13A
....................     
....................    suma = X+Y; 
03DA:  MOVF   34,W
03DB:  ADDWF  32,W
03DC:  MOVWF  36
03DD:  MOVF   33,W
03DE:  MOVWF  37
03DF:  MOVF   35,W
03E0:  BTFSC  03.0
03E1:  INCFSZ 35,W
03E2:  ADDWF  37,F
....................    resta = X-Y; 
03E3:  MOVF   34,W
03E4:  SUBWF  32,W
03E5:  MOVWF  38
03E6:  MOVF   33,W
03E7:  MOVWF  39
03E8:  MOVF   35,W
03E9:  BTFSS  03.0
03EA:  INCFSZ 35,W
03EB:  SUBWF  39,F
....................    multiplicacion = X*y; 
03EC:  MOVF   33,W
03ED:  MOVWF  47
03EE:  MOVF   32,W
03EF:  MOVWF  46
03F0:  MOVF   35,W
03F1:  MOVWF  49
03F2:  MOVF   34,W
03F3:  MOVWF  48
03F4:  CALL   181
03F5:  MOVF   79,W
03F6:  MOVWF  3B
03F7:  MOVF   78,W
03F8:  MOVWF  3A
....................    division = X/Y; 
03F9:  MOVF   33,W
03FA:  MOVWF  3F
03FB:  MOVF   32,W
03FC:  MOVWF  3E
03FD:  MOVF   35,W
03FE:  MOVWF  41
03FF:  MOVF   34,W
0400:  MOVWF  40
0401:  GOTO   31E
0402:  MOVF   79,W
0403:  MOVWF  3D
0404:  MOVF   78,W
0405:  MOVWF  3C
....................     
....................    printf ("El resutado de la Suma es: %Ld\r", suma); 
0406:  CLRF   3E
0407:  MOVF   3E,W
0408:  CALL   098
0409:  INCF   3E,F
040A:  MOVWF  77
040B:  MOVWF  48
040C:  CALL   13A
040D:  MOVLW  1B
040E:  SUBWF  3E,W
040F:  BTFSS  03.2
0410:  GOTO   407
0411:  MOVLW  10
0412:  MOVWF  04
0413:  MOVF   37,W
0414:  MOVWF  40
0415:  MOVF   36,W
0416:  MOVWF  3F
0417:  CALL   29E
0418:  MOVLW  0D
0419:  MOVWF  48
041A:  CALL   13A
....................    printf ("El resutado de la Resta es: %Ld\r", resta); 
041B:  CLRF   3E
041C:  MOVF   3E,W
041D:  CALL   0BC
041E:  INCF   3E,F
041F:  MOVWF  77
0420:  MOVWF  48
0421:  CALL   13A
0422:  MOVLW  1C
0423:  SUBWF  3E,W
0424:  BTFSS  03.2
0425:  GOTO   41C
0426:  MOVLW  10
0427:  MOVWF  04
0428:  MOVF   39,W
0429:  MOVWF  40
042A:  MOVF   38,W
042B:  MOVWF  3F
042C:  CALL   29E
042D:  MOVLW  0D
042E:  MOVWF  48
042F:  CALL   13A
....................    printf ("El resutado de la Multiplicacion es: %Ld\r", multiplicacion); 
0430:  CLRF   3E
0431:  MOVF   3E,W
0432:  CALL   0E1
0433:  INCF   3E,F
0434:  MOVWF  77
0435:  MOVWF  48
0436:  CALL   13A
0437:  MOVLW  25
0438:  SUBWF  3E,W
0439:  BTFSS  03.2
043A:  GOTO   431
043B:  MOVLW  10
043C:  MOVWF  04
043D:  MOVF   3B,W
043E:  MOVWF  40
043F:  MOVF   3A,W
0440:  MOVWF  3F
0441:  CALL   29E
0442:  MOVLW  0D
0443:  MOVWF  48
0444:  CALL   13A
....................    printf ("El resutado de la Division es: %Ld\r", division); 
0445:  CLRF   3E
0446:  MOVF   3E,W
0447:  CALL   112
0448:  INCF   3E,F
0449:  MOVWF  77
044A:  MOVWF  48
044B:  CALL   13A
044C:  MOVLW  1F
044D:  SUBWF  3E,W
044E:  BTFSS  03.2
044F:  GOTO   446
0450:  MOVLW  10
0451:  MOVWF  04
0452:  MOVF   3D,W
0453:  MOVWF  40
0454:  MOVF   3C,W
0455:  MOVWF  3F
0456:  CALL   29E
0457:  MOVLW  0D
0458:  MOVWF  48
0459:  CALL   13A
....................  
.................... } 
045A:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
